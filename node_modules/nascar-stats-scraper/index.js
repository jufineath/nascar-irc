/* Copyright (c) 2013 Justin King

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to
deal in the Software without restriction, including without limitation the
rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE. */

var events = require('events');
var util = require('util');

// One request object
var request = require('request');



// rawData holds the parsed JSON from NASCAR's leaderboard

var target_url;


function LeaderboardClient(url, newRefreshInterval) {
  var self = this;
  target_url = url

  self.rawData=[], self.runOrderIndex=[], self.pointsOrderIndex=[],
      self.luckyDogDriverIndex=[], self.lastLapSpeedIndex=[],self.bestLapSpeedIndex=[];
  
  
  // This method parses the leaderboard JSON, and creates some indexes for us
  this.update_leaderboard = function() {
    console.log('update_leaderboard begin');

    // Request the leaderboard from configured URL
    request(target_url, function (error, response, body) {
      if (!error && response.statusCode == 200) {
        // Proceed only if we don't detect an error, *and* status is good 

        // Store the JSON in the rawData array
        try {
          self.rawData = JSON.parse(body);
        } catch (err) {console.log('bad data:' + body);}

        if("length" in self.rawData) { console.log('update_leaderboard - bailing, no leaderboard'); return;}

        // Re-initialize the pointsOrderIndex index
        self.pointsOrderIndex = []
        // Loop through rawData.Passings and note the car number, points,
        //   points position and leaderbaord_data.Passings index
        for(var i=0;i<self.rawData.Passings.length;i++) {
          self.pointsOrderIndex[i] = {'CarNo' : self.rawData.Passings[i].CarNo,
          'Points' : self.rawData.Passings[i].Points,
          'PointsPosition' : self.rawData.Passings[i].PointsPosition,
          'index' : i};
        }
        // Sort the _points array by the PointsPosition property in order of
        //   1, 2, 3, ..., N
        self.pointsOrderIndex.sort(makeNumericCmp('PointsPosition'));


        // Re-initialize the runOrderIndex index
        self.runOrderIndex = []
        // Loop through rawData.Passings and note the car number, race rank/position,
        //  and leaderbaord_data.Passings index
        for(var i=0;i<self.rawData.Passings.length;i++) {
          self.runOrderIndex[i] = {'CarNo' : self.rawData.Passings[i].CarNo,
          'RaceRank' : self.rawData.Passings[i].RaceRank,
          'index' : i};
        }
        // Sort the _running array by the RaceRank (running order) property in order of
        //   1, 2, 3, ..., N
        self.runOrderIndex.sort(makeNumericCmp('RaceRank'));

        self.emit('updated_board', 'all good');
      


        // Loop through the array of cars and note the first one with an SFDelta = -1
        //   this is the first car NOT on the lead lap, and will be the car eligible
        //   for the Lucky Dog Pass
        // TODO: This should leverage the sorted _running array, not just assume that
        //         Passings is in running order  
        for(var i=0;i<self.runOrderIndex.length;i++) {
          if(self.rawData.Passings[i].SFDelta == -1) {
            self.luckyDogDriverIndex = i;
            break;
          }
        }



        // Capturing each car's speed as of their last completed lap
        //   putting it in _speed_last index, ordered by fastest
        self.lastLapSpeedIndex = []
        for(var i=0;i<self.rawData.Passings.length;i++) {
          self.lastLapSpeedIndex[i] = {'CarNo' : self.rawData.Passings[i].CarNo, 'LastLapSpeed' : self.rawData.Passings[i].LastLapSpeed, 'index' : i};
        }
        self.lastLapSpeedIndex.sort(makeNumericCmpRev('LastLapSpeed'));


        // Capturing each car's speed as of their BEST completed lap
        //   putting it in _speed_best index, ordered by fastest
        self.bestLapSpeedIndex = []
        for(var i=0;i<self.rawData.Passings.length;i++) {
          self.bestLapSpeedIndex[i] = {'CarNo' : self.rawData.Passings[i].CarNo, 'BestSpeed' : self.rawData.Passings[i].BestSpeed, 'index' : i};
        }
        self.bestLapSpeedIndex.sort(makeNumericCmpRev('BestSpeed'));
        // Print data for testing by uncommenting below
        // console.dir(data);

        // TODO: When this is extracted to nascar-lib there should be a property
        //  to allow you to define a callback after each leaderboard refresh
        //  or an 'event', as it were
       // try {postUpdateCallBbck();} catch (err) {}
       console.log('emitting done')
       self.emit('updated_board', 'all good');
      }  
      else {
        console.log('response: ' + response.statusCode);
        console.log('error: ' + error);
      }

    });


    // Commenting this out as it is probably not needed
    // Normal GC should wipe this. Will remove this comment and code at later date
    // 
    // TODO: See comment
    // delete fs; delete err; delete data;


    //try {postUpdateCallBack();} catch (err) {}

    console.log('update_leaderboard end');
  }
  
  
  // This function will search the leaderboard raw data and find matches by
  // either car number or driver name, and return an array of matching driver
  // indexes for the raw data JSON
  this.findDriverIndex = function findDriverIndex(search) {
    var driverIndexes = [];
    for (var index = 0; index < self.rawData.Passings.length; index++) {
      if (self.rawData.Passings[index].Driver.DriverName.toLowerCase().indexOf(search.toLowerCase()) !== -1 ||
          self.rawData.Passings[index].CarNo === search) {
        driverIndexes.push(index);
      }
     }
     return driverIndexes;
  }
  

  // Returns a string identifying (currentlap/totallaps)
  // Will return (0/0) if there is an error reading leaderboard data
  this.lapticker = function() {
    var ticker = '(0/0)';

    try {
      ticker = '(' + self.rawData.CurrentLapNumber + '/' +
                          self.rawData.LapsInRace + ')';
    } catch (err) {}

    return ticker;                      
  }

  var refreshInterval;
  // Allow the calling program to update the refresh interval
  this.updateInterval = function(newRefreshInterval) {
    clearInterval(refreshInterval);
    try{
      if(newRefreshInterval < 5000){
        refreshIntervalValue = 5000;
      }
      else if(newRefreshInterval > 300000){
        refreshIntervalValue = 300000
      }
      else {
        refreshIntervalValue = newRefreshInterval
      }
    } catch (err){
      self.emit('WARNING','Setting refresh interval to 60sec after: ' + err)
      refreshIntervalValue = 60000;
    }
    refreshInterval = setInterval(this.update_leaderboard, refreshIntervalValue);
    return refreshIntervalValue;
  }
  self.updateInterval(newRefreshInterval);
   //= setInterval(this.update_leaderboard, newRefreshInterval)
  events.EventEmitter.call(this);
}



function LapByLapClient(url, newRefreshInterval) {
  var self = this;
  //target_url = url
  racecache_path = '/Users/justin/Dropbox/dev/nascar-irc/racecache/'
  
  // require() in filesystem
  var fs = require('fs');
  
  
  var haveReadFileCache = 0;
  var raceCache={raceId: '0', seenLabels: []};
  self.rawData=[];
    
  
  // This method parses the leaderboard JSON, and creates some indexes for us
  this.updateLapByLap = function() {
    console.log('updateLapByLap begin');

 
    // Request the leaderboard from configured URL
    request(url, function (error, response, body) {
      if (!error && response.statusCode == 200) {
        // Proceed only if we don't detect an error, *and* status is good 
        // Store the JSON in the rawData array
        try {
          self.rawData = JSON.parse(body);
        } catch (err) {console.log('updateLapByLap bad data:' + body);}

        if("length" in self.rawData) { console.log('updateLapByLap - bailing, no lap-by-lap'); return;}

        //console.dir(self.rawData);
        raceCache.raceId = self.rawData.raceInfo.raceId;
        //console.log('raceid: ' + raceCache.raceId);
        
        if(haveReadFileCache === 0) {
          fs.readFile(racecache_path + raceCache.raceId + '.json', 'utf8', function (err, data) {
            if (err) {
              console.log('Error: ' + err);
              return;
            }

            raceCache = JSON.parse(data);
            haveReadFileCache = 1;

            //console.dir(data);
          });
        }
        
        console.log('updateLapByLap START parse labels ') 
        for(var i=0;i<self.rawData.raceInfo.lapInfo.length;i++) {
          //console.log('updateLapByLap parse labels i '+ i) 
          var found = 0;
          for(var j=0;j<raceCache.seenLabels.length;j++){
            //console.log('updateLapByLap parse labels j '+ j)
            if(self.rawData.raceInfo.lapInfo[i].label === raceCache.seenLabels[j]){
              //console.log('match in parse labels')
               found =1;
            }
          }
          if(found === 0) {
            console.log('emitting lapUpdate') ;//' for ' + self.rawData.raceInfo.lapInfo[i].info);
            self.emit('lapUpdate', self.rawData.raceInfo.lapInfo[i].label + '' + self.rawData.raceInfo.lapInfo[i].info);
            raceCache.seenLabels.push(self.rawData.raceInfo.lapInfo[i].label)
          }
        }
        console.log('updateLapByLap DONE parse labels ')
        
        fs.writeFile(racecache_path + raceCache.raceId + '.json', JSON.stringify(raceCache), function(err) {
            if(err) {
                console.log(err);
            } else {
                console.log("The file was saved!");
            }
        });
        
        /*

        // Re-initialize the runOrderIndex index
        self.runOrderIndex = []
        // Loop through rawData.Passings and note the car number, race rank/position,
        //  and leaderbaord_data.Passings index
        for(var i=0;i<self.rawData.Passings.length;i++) {
          self.runOrderIndex[i] = {'CarNo' : self.rawData.Passings[i].CarNo,
          'RaceRank' : self.rawData.Passings[i].RaceRank,
          'index' : i};
        }
        // Sort the _running array by the RaceRank (running order) property in order of
        //   1, 2, 3, ..., N
        self.runOrderIndex.sort(makeNumericCmp('RaceRank'));

        self.emit('updated_board', 'all good');
      


        // Loop through the array of cars and note the first one with an SFDelta = -1
        //   this is the first car NOT on the lead lap, and will be the car eligible
        //   for the Lucky Dog Pass
        // TODO: This should leverage the sorted _running array, not just assume that
        //         Passings is in running order  
        for(var i=0;i<self.runOrderIndex.length;i++) {
          if(self.rawData.Passings[i].SFDelta == -1) {
            self.luckyDogDriverIndex = i;
            break;
          }
        }



        // Capturing each car's speed as of their last completed lap
        //   putting it in _speed_last index, ordered by fastest
        self.lastLapSpeedIndex = []
        for(var i=0;i<self.rawData.Passings.length;i++) {
          self.lastLapSpeedIndex[i] = {'CarNo' : self.rawData.Passings[i].CarNo, 'LastLapSpeed' : self.rawData.Passings[i].LastLapSpeed, 'index' : i};
        }
        self.lastLapSpeedIndex.sort(makeNumericCmpRev('LastLapSpeed'));


        // Capturing each car's speed as of their BEST completed lap
        //   putting it in _speed_best index, ordered by fastest
        self.bestLapSpeedIndex = []
        for(var i=0;i<self.rawData.Passings.length;i++) {
          self.bestLapSpeedIndex[i] = {'CarNo' : self.rawData.Passings[i].CarNo, 'BestSpeed' : self.rawData.Passings[i].BestSpeed, 'index' : i};
        }
        self.bestLapSpeedIndex.sort(makeNumericCmpRev('BestSpeed'));
        // Print data for testing by uncommenting below
        // console.dir(data);

        // TODO: When this is extracted to nascar-lib there should be a property
        //  to allow you to define a callback after each leaderboard refresh
        //  or an 'event', as it were
       // try {postUpdateCallBbck();} catch (err) {}
       */
       console.log('emitting done')
       self.emit('updatedLapByLap', 'all good');
      }  
       else {
         console.log('response: ' + response.statusCode);
         console.log('error: ' + error);
       }

    });


    // Commenting this out as it is probably not needed
    // Normal GC should wipe this. Will remove this comment and code at later date
    // 
    // TODO: See comment
    // delete fs; delete err; delete data;


    //try {postUpdateCallBack();} catch (err) {}

    console.log('updateLapByLap end');
  }
  
  


  var refreshInterval;
  // Allow the calling program to update the refresh interval
  this.updateInterval = function(newRefreshInterval) {
    clearInterval(refreshInterval);
    try{
      if(newRefreshInterval < 5000){
        refreshIntervalValue = 5000;
      }
      else if(newRefreshInterval > 300000){
        refreshIntervalValue = 300000
      }
      else {
        refreshIntervalValue = newRefreshInterval
      }
    } catch (err){
      self.emit('WARNING','Setting refresh interval to 60sec after: ' + err)
      refreshIntervalValue = 60000;
    }
    refreshInterval = setInterval(this.updateLapByLap, refreshIntervalValue);
    return refreshIntervalValue;
  }
  self.updateInterval(newRefreshInterval);
   //= setInterval(this.update_leaderboard, newRefreshInterval)
  events.EventEmitter.call(this);
}


util.inherits(LeaderboardClient, events.EventEmitter);
exports.LeaderboardClient = LeaderboardClient;
util.inherits(LapByLapClient, events.EventEmitter);
exports.LapByLapClient = LapByLapClient;





// These are comparators for our leaderboard indexes
// They allow us to sort by a numeric property such as Points, RaceRank
function makeNumericCmp(property) {
    return function (a, b) {
        return parseInt(a[property]) - parseInt(b[property]);
    };
}
function makeNumericCmpRev(property) {
    return function (a, b) {
        return parseInt(b[property]) - parseInt(a[property]);
    };
}
