/* Copyright (c) 2013 Justin King

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to
deal in the Software without restriction, including without limitation the
rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE. */

// Need events for letting calling program know when things are updated
var events = require('events');

// Use util to graft events onto our objects
var util = require('util');

// One request object for our HTTP calls to leaderboard and lapbylap data
var request = require('request');

// The LeaderboardClient is the object which is used for refreshing and
// monitoring the NASCAR leaderboard data
// It takes a url, which is the URL to the race data
// It takes a refresh interval which is how often to refresh that data
//   Note: It will only allow an interval between 5 and 300 seconds.
function LeaderboardClient(url, newRefreshInterval) {
  var self = this;

  // rawData is where we store the JSON that comes in on the latest request
  // NOTE: We do not store prior JSON sets. Only the most recent.
  self.rawData=[];
  
  
  // This method parses the leaderboard JSON, and creates some indexes for us
  this.updateLeaderboard = function() {
    self.emit('info', 'updateLeaderboard begin');

    // Request the leaderboard from configured URL
    request(url, function (error, response, body) {
      if (!error && response.statusCode == 200) {
        // Proceed only if we don't detect an error, *and* status is good

        // Store the JSON in the rawData array
        try {
          self.rawData = JSON.parse(body);
        }
        catch (err) {
          self.emit('error', 'bad data:' + body);
          self.emit('error', 'from url:' + url);
          self.emit('error', 'response.statusCode: ' + response.statusCode);
          return;
        }

        // Sanity check the JSON, make sure it's leaderboard data
        var goodRawData = sanityCheckLeaderboardJSON(self.rawData);
        if(!goodRawData) {
          self.emit('error', 'updateLeaderboard - bailing, bad leaderboard');
          return;
        }

        
                
        // Re-initialize the indexes
        
        // runOrderIndex is for storing an index of the cars by race position
        // First item in the array is first place car, second is second...
        self.runOrderIndex=[];

        // pointsOrderIndex to store an index of cars by point position
        self.pointsOrderIndex=[];

        // luckyDogDriverIndex is the position in rawData.Passings of the
        //  driver in the "lucky dog" position (first driver -1 lap)
        self.luckyDogDriverIndex = -1;

        // These two indexes are used to find cars by their lap speed
        self.lastLapSpeedIndex=[];
        self.bestLapSpeedIndex=[];

        // Loop through Passings and build each index
        var cars = self.rawData.Passings;
        for(var i=0; i < cars.length; i++) {
          var carNo = cars[i].CarNo;
          var points = cars[i].Points;
          var pointsPosition = cars[i].PointsPosition;
          var raceRank = cars[i].RaceRank;
          var lastLapSpeed = cars[i].LastLapSpeed;
          var bestLapSpeed = cars[i].BestSpeed;
          
          self.pointsOrderIndex[i] = { 'CarNo' : carNo,
                                      'Points' : points,
                              'PointsPosition' : pointsPosition,
                                       'index' : i};
                                       
          self.runOrderIndex[i] = {'CarNo' : carNo,
                                'RaceRank' : raceRank,
                                   'index' : i};
                                   
          self.lastLapSpeedIndex[i] = {'CarNo' : carNo,
                                'LastLapSpeed' : lastLapSpeed,
                                       'index' : i};
                                       
          self.bestLapSpeedIndex[i] = {'CarNo' : carNo,
                                   'BestSpeed' : bestLapSpeed,
                                       'index' : i};
                                       
        }

        // Sort the _points array by the PointsPosition property in order of
        //   1, 2, 3, ..., N
        self.pointsOrderIndex.sort(makeNumericCmp('PointsPosition'));

        // Sort the _running array by the RaceRank (running order)
        // property in order of 1, 2, 3, ..., N
        self.runOrderIndex.sort(makeNumericCmp('RaceRank'));

        // Sort index by speed of last lap, largest N first
        self.lastLapSpeedIndex.sort(makeNumericCmpRev('LastLapSpeed'));

        // Sort index by speed of best lap, largest N first
        self.bestLapSpeedIndex.sort(makeNumericCmpRev('BestSpeed'));

        // Loop through the array of cars and note the first one
        // with an SFDelta = -1
        // this is the first car NOT on the lead lap, and will
        // be the car eligible for the Lucky Dog Pass
        for(var i=0;i<self.runOrderIndex.length;i++) {
          if(cars[i].SFDelta == -1) {
            self.luckyDogDriverIndex = i;
            break;
          }
        }

        // Tell our calling apps we're all done
        self.emit('info', 'updateLeaderboard end');
        self.emit('updated_board', 'all good');
      }  
      else {
        //There was an error, let's let folks know.
        self.emit('error', 'response: ' + response.statusCode);
        self.emit('error', 'error: ' + error);
      }

    });
  }
  
  
  // This function will search the leaderboard raw data and find matches by
  // either car number or driver name, and return an array of matching driver
  // indexes for the raw data JSON
  this.findDriverIndex = function findDriverIndex(search) {
    var driverIndexes = [];
    for (var index = 0; index < self.rawData.Passings.length; index++) {
      if (self.rawData.Passings[index].Driver.DriverName.toLowerCase().indexOf(search.toLowerCase()) !== -1 ||
          self.rawData.Passings[index].CarNo === search) {
        driverIndexes.push(index);
      }
     }
     return driverIndexes;
  }
  
  // This function performs various sanity checks on the rawData object
  // after we parse the JSON sent back for the leaderboard
  function sanityCheckLeaderboardJSON(rawData) {
    //TODO: This should do json-schema validation
    // Right now we just do some basic crappy tests
    // these are good so long as NASCAR doesn't make some subtle changes
    // and to make sure we've got the right URL, etc so we don't totally fail
    try{
      if(!("Passings" in rawData)) {
        self.emit('error','Leaderboard data JSON is missing Passings array');
        return 0;
      }
      if(!("AverageRestartSpeed" in rawData.Passings[0])) {
        self.emit('error','Leaderboard data JSON is missing' + 
                          ' AverageRestartSpeed in first Passings');
        return 0;
      }
      if(!("RaceID" in rawData)) {
        self.emit('error','Leaderboard data JSON is missing RaceID');
        return 0;
      }
      if(!("LapsInRace" in rawData)) {
        self.emit('error','Leaderboard data JSON is missing LapsInRace');
        return 0;
      }
      if(!("LapsInRace" in rawData)) {
        self.emit('error','Leaderboard data JSON is missing LapsInRace');
        return 0;
      }
    }
    catch (err) {
      self.emit('error','Leaderboard data JSON couldn\'t be sanity checked');
      self.emit('error', err);
      return 0;
    }
    return 1;
  }

  // Returns a string identifying (currentlap/totallaps)
  // Will return (0/0) if there is an error reading leaderboard data
  this.lapticker = function() {
    var ticker = '(0/0)';

    try {
      ticker = '(' + self.rawData.CurrentLapNumber + '/' +
                          self.rawData.LapsInRace + ')';
    } catch (err) {}

    return ticker;                      
  }

  var refreshInterval;
  // Allow the calling program to update the refresh interval
  this.updateInterval = function(newRefreshInterval) {
    clearInterval(refreshInterval);
    try{
      if(newRefreshInterval < 5000){
        refreshIntervalValue = 5000;
      }
      else if(newRefreshInterval > 300000){
        refreshIntervalValue = 300000
      }
      else {
        refreshIntervalValue = newRefreshInterval
      }
    } catch (err){
      self.emit('WARNING','Setting refresh interval to 60sec after: ' + err)
      refreshIntervalValue = 60000;
    }
    refreshInterval = setInterval(this.updateLeaderboard, refreshIntervalValue);
    return refreshIntervalValue;
  }
  self.updateInterval(newRefreshInterval);
   //= setInterval(this.updateLeaderboard, newRefreshInterval)
  events.EventEmitter.call(this);
}

function LapByLapClient(url, newRefreshInterval, racecachePath) {
  var self = this;
  
  // require() in filesystem
  var fs = require('fs');
  
  // Instance variable to indicate if we're read the file cache
  // We will only try/do it once
  var haveReadFileCache = 0;
  
  // Our cache of the data that we've seen (and for which race)
  //  we'll be persisting this to storage as we go
  var raceCache={raceId: '0', seenLabels: []};

  // This method parses the lap-by-lap JSON, and raises an event
  //  for each new lap-by-lap message that it sees
  this.updateLapByLap = function() {
    self.emit('info', 'updateLapByLap begin');
 
    // Request the lap-by-lap from configured URL
    request(url, function (error, response, body) {
      if (!error && response.statusCode == 200) {
        // Proceed only if we don't detect an error, *and* status is good 
        
        // Store the JSON in the rawData array
        try {
          self.rawData = JSON.parse(body);
        }
        catch (err) {
          self.emit('error', 'bad data:' + body);
          self.emit('error', 'from url:' + url);
          self.emit('error', 'response.statusCode: ' + response.statusCode);
          return;
        }


        // Sanity check the JSON, make sure it's leaderboard data
        var goodRawData = sanityCheckLapByLapJSON(self.rawData);
        if(!goodRawData) {
          self.emit('error', 'updateLapByLap - bailing, bad JSON data');
          return;
        }

        // Do we have a new race?
        if(raceCache.raceId !== self.rawData.raceInfo.raceId) {
          // If so, we should try to restore cache from file
          haveReadFileCache = 0;
          raceCache.raceId = self.rawData.raceInfo.raceId;
        }
        
        // Get a normalized file handle for file operations
        var path = require('path')
        var racecacheFile = path.join(racecachePath, 
                                      raceCache.raceId + '.json');
        
        // If we have not yet read race from file and if it exists...
        if(haveReadFileCache === 0 && fs.existsSync(racecacheFile)) {
          //Then try to read it 
          try {
            data = fs.readFileSync(racecacheFile, 'utf8');
            raceCache = JSON.parse(data);
            self.emit('info', 'loading lap-by-lap racecache from disk');
          }
          catch (err) {
            self.emit('error','problem reading racecache, moving on');
          }
          // Good or bad, we're not trying again until raceId changes  
          haveReadFileCache = 1;
        }
        
        self.emit('info', 'updateLapByLap START parse labels ') 
        for(var i=0;i<self.rawData.raceInfo.lapInfo.length;i++) {
          //self.emit('info', 'updateLapByLap parse labels i '+ i) 
          var found = 0;
          for(var j=0;j<raceCache.seenLabels.length;j++){
            //self.emit('info', 'updateLapByLap parse labels j '+ j)
            if(self.rawData.raceInfo.lapInfo[i].label === raceCache.seenLabels[j]){
              //self.emit('info', 'match in parse labels')
               found =1;
            }
          }
          if(found === 0) {
            self.emit('info', 'emitting lapUpdate') ;//' for ' + self.rawData.raceInfo.lapInfo[i].info);
            self.emit('lapUpdate', self.rawData.raceInfo.lapInfo[i].label + '' + self.rawData.raceInfo.lapInfo[i].info);
            raceCache.seenLabels.push(self.rawData.raceInfo.lapInfo[i].label)
          }
        }
        self.emit('info', 'updateLapByLap DONE parse labels ')
        
        fs.writeFile(racecachePath + raceCache.raceId + '.json', JSON.stringify(raceCache), function(err) {
            if(err) {
                self.emit('info', err);
            } else {
                self.emit('info', "The file was saved!");
            }
        });
        
      
       self.emit('info', 'emitting done')
       self.emit('updatedLapByLap', 'all good');
      }  
       else {
         self.emit('info', 'response: ' + response.statusCode);
         self.emit('info', 'error: ' + error);
       }

    });


    self.emit('info', 'updateLapByLap end');
  }
  
  // This function performs various sanity checks on the rawData object
  // after we parse the JSON sent back for the lap-by-lap
  function sanityCheckLapByLapJSON(rawData) {
    //TODO: This should do json-schema validation
    // Right now we just do some basic crappy tests
    // these are good so long as NASCAR doesn't make some subtle changes
    // and to make sure we've got the right URL, etc so we don't totally fail
    try{
      if(!("raceInfo" in rawData)) {
        self.emit('error','Lap-by-lap data JSON is missing raceInfo object');
        return 0;
      }
      if(!("lapInfo" in rawData.raceInfo)) {
        self.emit('error','Lap-by-lap data JSON is missing lapInfo array');
        return 0;
      }
      if(!("raceId" in rawData.raceInfo)) {
        self.emit('error','Lap-by-lap data JSON is missing raceId');
        return 0;
      }
    }
    catch (err) {
      self.emit('error','Lap-by-lap data JSON couldn\'t be sanity checked');
      self.emit('error', err);
      return 0;
    }
    return 1;
  }

  var refreshInterval;
  // Allow the calling program to update the refresh interval
  this.updateInterval = function(newRefreshInterval) {
    clearInterval(refreshInterval);
    try{
      if(newRefreshInterval < 5000){
        refreshIntervalValue = 5000;
      }
      else if(newRefreshInterval > 300000){
        refreshIntervalValue = 300000
      }
      else {
        refreshIntervalValue = newRefreshInterval
      }
    } catch (err){
      self.emit('info','WARNING: Setting refresh interval to 60sec after: ' + err)
      refreshIntervalValue = 60000;
    }
    refreshInterval = setInterval(this.updateLapByLap, refreshIntervalValue);
    return refreshIntervalValue;
  }
  self.updateInterval(newRefreshInterval);
  events.EventEmitter.call(this);
}

// Graft the events library onto the LeaderboardClient and LapByLapClient
// and export the Clients for use by callers
util.inherits(LeaderboardClient, events.EventEmitter);
exports.LeaderboardClient = LeaderboardClient;
util.inherits(LapByLapClient, events.EventEmitter);
exports.LapByLapClient = LapByLapClient;

// These are comparators for our leaderboard indexes
// They allow us to sort by a numeric property such as Points, RaceRank
function makeNumericCmp(property) {
    return function (a, b) {
        return parseInt(a[property]) - parseInt(b[property]);
    };
}
function makeNumericCmpRev(property) {
    return function (a, b) {
        return parseInt(b[property]) - parseInt(a[property]);
    };
}
